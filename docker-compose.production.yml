# CodiesVibe Production Environment
# Docker Compose configuration for production deployment with Nginx reverse proxy
# Integrates with infrastructure stack (docker-compose.infra.yml)

services:
  # Nginx Reverse Proxy and Static File Server
  nginx:
    image: nginx:1.25-alpine
    container_name: codiesvibe-nginx
    # Install curl for health checks
    command: sh -c "apk add --no-cache curl && nginx -g 'daemon off;'"
    ports:
      - "80:80"    # HTTP
      - "443:443"  # HTTPS (for future SSL termination)
    volumes:
      # Nginx configuration
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      # Cloudflare IP ranges script and configuration
      - ./scripts:/scripts:ro
      - ./includes:/etc/nginx/includes:ro
      # Static files from frontend build
      - frontend_dist:/usr/share/nginx/html:ro
      # SSL certificates (for future use)
      - nginx_ssl:/etc/nginx/ssl:ro
    environment:
      - NGINX_ENVSUBST_TEMPLATE_DIR=/etc/nginx/templates
      - NGINX_ENVSUBST_TEMPLATE_SUFFIX=.template
      - BACKEND_HOST=backend
      - BACKEND_PORT=4000
    networks:
      - codiesvibe-network
    depends_on:
      frontend-init:
        condition: service_completed_successfully
      backend:
        condition: service_healthy
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:80/health"]
      interval: 30s
      timeout: 10s
      start_period: 10s
      retries: 3

  # Frontend Init Container - Builds and copies assets, then exits
  frontend-init:
    # Use pre-built GHCR image for production deployments
    # image: ghcr.io/foyzulkarim/codiesvibe-frontend:${VERSION:-latest}
    # Fallback: Build locally if GHCR image unavailable
    build:
      context: .
      dockerfile: Dockerfile.frontend
      target: production
      args:
        - BUILD_DATE=${BUILD_DATE}
        - GIT_COMMIT=${GIT_COMMIT}
        - VERSION=${VERSION}
        # Vite build-time environment variables (from .env file)
        - VITE_API_URL=${VITE_API_URL}
        - NODE_ENV=production
    container_name: codiesvibe-frontend-init
    volumes:
      # Share built files with Nginx
      - frontend_dist:/shared/dist
    command: sh -c "echo 'Copying frontend assets...' && cp -r /usr/share/nginx/html/* /shared/dist/ && echo 'Frontend assets copied successfully' && ls -la /shared/dist/"
    environment:
      - NODE_ENV=production
      # Note: VITE_* vars are embedded at build time, these are for container metadata only
      - VITE_APP_VERSION=${VERSION:-production}
      - VITE_BUILD_DATE=${BUILD_DATE:-$(date -u +'%Y-%m-%dT%H:%M:%SZ')}
      - VITE_GIT_COMMIT=${GIT_COMMIT:-$(git rev-parse --short HEAD)}
    networks:
      - codiesvibe-network
    restart: "no"  # One-time init container
    user: root  # Need root to write to volume

  # Note: Database seeding should be done manually
  # Run: npm run seed:production (with proper environment variables)

  # Search-API Production Service
  search-api:
    # Build locally for production deployments
    build:
      context: .
      dockerfile: Dockerfile.search-api
      target: production
      args:
        - BUILD_DATE=${BUILD_DATE:-$(date -u +'%Y-%m-%dT%H:%M:%SZ')}
        - GIT_COMMIT=${GIT_COMMIT:-$(git rev-parse --short HEAD)}
    container_name: codiesvibe-search-api-prod
    # Expose port 4003 for troubleshooting (accessed through Nginx reverse proxy normally)
    ports:
      - "4003:4003"  # Direct search-api access for troubleshooting
    expose:
      - "4003"
    environment:
      - NODE_ENV=production
      - PORT=4003
      # Cloud infrastructure connections (from .env file)
      - MONGODB_URI=${MONGODB_URI}
      - MONGODB_DB_NAME=${MONGODB_DB_NAME}
      # Qdrant Cloud configuration (from .env file)
      - QDRANT_URL=${QDRANT_URL}
      - QDRANT_API_KEY=${QDRANT_API_KEY}
      - QDRANT_HOST=${QDRANT_HOST}
      - QDRANT_PORT=${QDRANT_PORT}
      - QDRANT_COLLECTION_NAME=${QDRANT_COLLECTION_NAME}
      # AI service endpoints (from .env file)
      - TOGETHER_API_KEY=${TOGETHER_API_KEY}
      # Production security and CORS (from .env file)
      - CORS_ORIGINS=${CORS_ORIGINS}
      - ALLOWED_ORIGINS=${ALLOWED_ORIGINS}
      - ENABLE_SECURITY_HEADERS=${ENABLE_SECURITY_HEADERS}
      - ENABLE_RATE_LIMITING=${ENABLE_RATE_LIMITING}
      - ENABLE_VECTOR_VALIDATION=${ENABLE_VECTOR_VALIDATION}
      # Search configuration (from .env file)
      - SEARCH_USE_MULTIVECTOR=${SEARCH_USE_MULTIVECTOR}
      - SEARCH_RRF_K=${SEARCH_RRF_K}
      - SEARCH_SOURCE_WEIGHTS=${SEARCH_SOURCE_WEIGHTS}
      - SEARCH_SCORE_THRESHOLD=${SEARCH_SCORE_THRESHOLD}
      # Performance and logging (from .env file)
      - LOG_LEVEL=${LOG_LEVEL}
      - ENABLE_CACHE=${ENABLE_CACHE}
      - CACHE_TTL=${CACHE_TTL}
    networks:
      - codiesvibe-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:4003/health"]
      interval: 30s
      timeout: 10s
      start_period: 20s
      retries: 3
    # Security: read-only filesystem with specific writable paths
    read_only: true
    tmpfs:
      - /tmp:rw,size=100M,mode=1777
      - /app/logs:rw,size=50M,mode=0755
    # Resource limits for production
    deploy:
      resources:
        limits:
          memory: 1G
          cpus: '1.0'
        reservations:
          memory: 512M
          cpus: '0.5'
    # Security: Drop all capabilities except required ones
    cap_drop:
      - ALL
    cap_add:
      - SETUID
      - SETGID
    # Security: Prevent privilege escalation
    security_opt:
      - no-new-privileges:true

  # Backend Production Service
  backend:
    # Build locally for production deployments
    build:
      context: .
      dockerfile: Dockerfile.backend
      target: production
      args:
        - BUILD_DATE=${BUILD_DATE:-$(date -u +'%Y-%m-%dT%H:%M:%SZ')}
        - GIT_COMMIT=${GIT_COMMIT:-$(git rev-parse --short HEAD)}
    container_name: codiesvibe-backend-prod
    # Expose port 4000 for troubleshooting (accessed through Nginx reverse proxy normally)
    ports:
      - "4000:4000"  # Direct backend access for troubleshooting
    expose:
      - "4000"
    environment:
      - NODE_ENV=production
      - PORT=4000
      # Cloud infrastructure connections (from .env file)
      - MONGODB_URI=${MONGODB_URI}
      # Production secrets (from .env file)
      - JWT_SECRET=${JWT_SECRET}
      - COOKIE_SECRET=${COOKIE_SECRET}
      - CSRF_SECRET=${CSRF_SECRET}
      # CORS configuration for subdomain architecture (from .env file)
      - CORS_ORIGIN=${CORS_ORIGIN}
      # Production rate limiting (from .env file)
      - RATE_LIMIT_WINDOW=${RATE_LIMIT_WINDOW}
      - RATE_LIMIT_MAX=${RATE_LIMIT_MAX}
      # Production settings (from .env file)
      - TRUST_PROXY=${TRUST_PROXY}
      - SHUTDOWN_TIMEOUT=${SHUTDOWN_TIMEOUT}
      # Search API connection (internal Docker network)
      - SEARCH_API_URL=${SEARCH_API_URL}
      # Logging configuration (from .env file)
      - LOG_LEVEL=${LOG_LEVEL}
    networks:
      - codiesvibe-network
    depends_on:
      search-api:
        condition: service_healthy
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "node", "healthcheck.js"]
      interval: 30s
      timeout: 10s
      start_period: 20s
      retries: 3
    # Security: read-only filesystem with specific writable paths
    read_only: true
    tmpfs:
      - /tmp:rw,size=100M,mode=1777
      - /app/logs:rw,size=50M,mode=0755
    # Resource limits for production
    deploy:
      resources:
        limits:
          memory: 512M
          cpus: '0.5'
        reservations:
          memory: 256M
          cpus: '0.25'
    # Security: Drop all capabilities except required ones
    cap_drop:
      - ALL
    cap_add:
      - SETUID
      - SETGID
    # Security: Prevent privilege escalation
    security_opt:
      - no-new-privileges:true

# External network configuration (must be created by docker-compose.infra.yml first)
networks:
  codiesvibe-network:
    external: true
    name: codiesvibe-network

# Volume definitions for production data
volumes:
  # Frontend build artifacts shared between frontend build and nginx
  frontend_dist:
    driver: local
  # SSL certificates for Nginx
  nginx_ssl:
    driver: local
  # Nginx includes for dynamic configurations
  nginx_includes:
    driver: local
  # Nginx cache and temporary files
  nginx_cache:
    driver: local