# Dockerfile Configuration Contract
# Defines the expected structure and validation rules for all Dockerfiles

# Frontend Dockerfile Contract
frontend-dockerfile-contract:
  base_image:
    required: true
    pattern: "node:[0-9]+.*-alpine"
    security: minimal-attack-surface

  multi_stage:
    required: true
    stages:
      - name: dependencies
        purpose: Install package dependencies
        requirements:
          - WORKDIR /app
          - COPY package*.json ./
          - RUN npm ci

      - name: builder
        purpose: Build TypeScript application
        requirements:
          - COPY . .
          - RUN npm run build
          - FROM dependencies AS builder

      - name: development
        purpose: Development with hot reload
        requirements:
          - FROM dependencies AS development
          - EXPOSE 3000
          - CMD ["npm", "run", "start"]

      - name: production
        purpose: Production optimized image
        requirements:
          - FROM node:18-alpine AS production
          - RUN addgroup -g 1001 nodejs && adduser -S nodejs -u 1001
          - WORKDIR /app
          - COPY package*.json ./
          - RUN npm ci --only=production
          - COPY --from=builder --chown=nodejs:nodejs /app/build ./build
          - USER nodejs
          - EXPOSE 3000
          - CMD ["npx", "serve", "-s", "build", "-l", "3000"]

  security_requirements:
    user:
      required: true
      non_root: true
      uid: 1001
      gid: 1001

    file_permissions:
      required: true
      owner: nodejs:nodejs

    read_only:
      recommended: true
      writable_paths:
        - /tmp
        - /app/logs

    capabilities:
      drop: ["ALL"]
      add: [] # No additional capabilities needed

# Backend Dockerfile Contract
backend-dockerfile-contract:
  base_image:
    required: true
    pattern: "node:[0-9]+.*-alpine"
    security: minimal-attack-surface

  multi_stage:
    required: true
    stages:
      - name: dependencies
        purpose: Install package dependencies
        requirements:
          - WORKDIR /app
          - COPY package*.json ./
          - RUN npm ci

      - name: builder
        purpose: Build TypeScript application
        requirements:
          - FROM dependencies AS builder
          - COPY . .
          - RUN npm run build

      - name: development
        purpose: Development with hot reload and debugging
        requirements:
          - FROM dependencies AS development
          - COPY . .
          - EXPOSE 3001 9229
          - CMD ["npm", "run", "start:dev"]

      - name: production
        purpose: Production optimized image
        requirements:
          - FROM node:18-alpine AS production
          - RUN addgroup -g 1001 nodejs && adduser -S nodejs -u 1001
          - WORKDIR /app
          - COPY package*.json ./
          - RUN npm ci --only=production
          - COPY --from=builder --chown=nodejs:nodejs /app/dist ./dist
          - USER nodejs
          - EXPOSE 3001
          - HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 CMD node healthcheck.js || exit 1
          - CMD ["node", "dist/main.js"]

  health_check:
    required: true
    properties:
      interval: 30s
      timeout: 10s
      start_period: 5s
      retries: 3
      test: ["CMD", "node", "healthcheck.js"]

  security_requirements:
    user:
      required: true
      non_root: true
      uid: 1001
      gid: 1001

    file_permissions:
      required: true
      owner: nodejs:nodejs

    read_only:
      recommended: true
      writable_paths:
        - /tmp
        - /app/logs

# Common Dockerfile Rules
common_dockerfile_rules:
  layer_optimization:
    required: true
    rules:
      - Combine RUN commands to minimize layers
      - Copy package files before source code for better caching
      - Use .dockerignore to exclude unnecessary files
      - Order commands from least to most frequently changing

  caching_strategy:
    required: true
    rules:
      - COPY package*.json before COPY . .
      - Install dependencies before copying source code
      - Use multi-stage builds to separate build and runtime
      - Leverage build cache for faster builds

  image_size:
    target: < 100MB for production images
    strategies:
      - Use Alpine Linux base images
      - Multi-stage builds to exclude dev dependencies
      - Remove build tools from final image
      - Use npm ci --only=production

  security:
    required_practices:
      - Non-root user execution
      - Minimal base image (Alpine)
      - No secrets in image layers
      - Specific package versions (no latest tags)
      - Vulnerability scanning integration

    forbidden_practices:
      - Running as root user
      - Embedding secrets in ENV or COPY commands
      - Using ADD instead of COPY
      - Installing unnecessary packages
      - Using outdated base images

  labels:
    required:
      - org.opencontainers.image.title
      - org.opencontainers.image.description
      - org.opencontainers.image.version
      - org.opencontainers.image.created
      - org.opencontainers.image.source

  environment_variables:
    node_env:
      required: true
      validation: development|production|test

    port:
      required: true
      validation: 1024-65535

    log_level:
      default: info
      validation: error|warn|info|debug

# Validation Rules
dockerfile_validation:
  syntax:
    required:
      - Valid Dockerfile syntax
      - All instructions properly formatted
      - Required stages present for multi-stage builds

  security:
    required:
      - Non-root user specified
      - No hardcoded secrets
      - Minimal base image used
      - Health check implemented (for backend)

  performance:
    required:
      - Layer count minimized
      - Build cache optimization
      - Production dependencies only in final stage
      - Image size under target threshold

  compatibility:
    required:
      - Docker version compatibility (>= 20.10)
      - BuildKit compatibility
      - Multi-platform support (amd64, arm64)

# Testing Requirements
dockerfile_testing:
  unit_tests:
    required:
      - Image builds successfully
      - Final image size validation
      - Security scan passes
      - Non-root user verification

  integration_tests:
    required:
      - Container starts successfully
      - Health check passes
      - Application responds correctly
      - External dependencies connect

  security_tests:
    required:
      - Vulnerability scan (Trivy, Docker Scout)
      - User permissions verification
      - File system security audit
      - Network security validation