import { Tool } from '../types';
import { EvaluationResult } from '../evaluation/evaluator';
import { LLMPlan } from '../planning/llm-planner';
import { Annotation } from '@langchain/langgraph';

/**
 * LangGraph state schema for the search-api application
 * This state schema manages the flow of data through the LangGraph workflow
 */

// Define the state annotation
export const GraphStateAnnotation = Annotation.Root({
  // The original user query
  query: Annotation<string>,
  
  // The execution plan generated by the planner
  plan: Annotation<LLMPlan | null>,
  
  // The results from executing the plan (using Tool type as SearchResult)
  results: Annotation<Tool[] | null>,
  
  // The evaluation of the results
  evaluation: Annotation<EvaluationResult | null>,
  
  // The final response to the user
  response: Annotation<string | null>,
  
  // Whether the system needs clarification from the user
  needsClarification: Annotation<boolean>,
  
  // The question to ask the user for clarification
  clarificationQuestion: Annotation<string | null>,
  
  // Any error that occurred during execution
  error: Annotation<string | null>,
  
  // Additional metadata
  metadata: Annotation<Record<string, any>>,
});

// Type alias for the state
export type GraphState = typeof GraphStateAnnotation.State;

/**
 * Initial state factory function
 */
export function createInitialState(query: string): GraphState {
  return {
    query,
    plan: null,
    results: null,
    evaluation: null,
    response: null,
    needsClarification: false,
    clarificationQuestion: null,
    error: null,
    metadata: {
      startTime: new Date().toISOString(),
      iterationCount: 0,
      sessionId: generateSessionId(),
    },
  };
}

/**
 * Generate a unique session ID
 */
function generateSessionId(): string {
  return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

/**
 * Update state with new plan
 */
export function updateStateWithPlan(state: GraphState, plan: LLMPlan): GraphState {
  return {
    ...state,
    plan,
    metadata: {
      ...state.metadata,
      lastPlanUpdate: new Date().toISOString(),
    },
  };
}

/**
 * Update state with new results
 */
export function updateStateWithResults(state: GraphState, results: Tool[]): GraphState {
  return {
    ...state,
    results,
    metadata: {
      ...state.metadata,
      lastResultsUpdate: new Date().toISOString(),
      resultCount: results.length,
    },
  };
}

/**
 * Update state with evaluation
 */
export function updateStateWithEvaluation(state: GraphState, evaluation: EvaluationResult): GraphState {
  return {
    ...state,
    evaluation,
    metadata: {
      ...state.metadata,
      lastEvaluationUpdate: new Date().toISOString(),
      evaluationScore: evaluation.overallScore,
    },
  };
}

/**
 * Update state with clarification request
 */
export function updateStateWithClarification(state: GraphState, question: string): GraphState {
  return {
    ...state,
    needsClarification: true,
    clarificationQuestion: question,
    metadata: {
      ...state.metadata,
      clarificationRequested: new Date().toISOString(),
    },
  };
}

/**
 * Update state with error
 */
export function updateStateWithError(state: GraphState, error: string): GraphState {
  return {
    ...state,
    error,
    metadata: {
      ...state.metadata,
      errorOccurred: new Date().toISOString(),
    },
  };
}

/**
 * Update state with final response
 */
export function updateStateWithResponse(state: GraphState, response: string): GraphState {
  return {
    ...state,
    response,
    metadata: {
      ...state.metadata,
      completedAt: new Date().toISOString(),
    },
  };
}

/**
 * Check if state is complete
 */
export function isStateComplete(state: GraphState): boolean {
  return !!state.response || !!state.error;
}

/**
 * Check if state has results
 */
export function stateHasResults(state: GraphState): boolean {
  return !!(state.results && state.results.length > 0);
}

/**
 * Get state summary for debugging
 */
export function getStateSummary(state: GraphState): string {
  const parts = [
    `Query: "${state.query}"`,
    `Has Plan: ${!!state.plan}`,
    `Results: ${state.results?.length || 0}`,
    `Has Evaluation: ${!!state.evaluation}`,
    `Needs Clarification: ${state.needsClarification}`,
    `Has Error: ${!!state.error}`,
    `Has Response: ${!!state.response}`,
  ];
  
  return parts.join(' | ');
}
