version: 1
unified_spec: ./UNIFIED-STATE-SPEC.md
stage_specs:
  intent: ./states-docs/intent.md
  planner: ./states-docs/query-planner.md
  executor: ./states-docs/query-executor.md

graphs:
  intent-extraction.graph.ts:
    writes: [signals, intent]
    validates: [intent]
  query-planning.graph.ts:
    writes: [planning]
    validates: [planning]
  execution.graph.ts:
    writes: [execution, results, completion]
    validates: [execution, results, completion]

nodes:
  - name: QueryPreprocessorNode
    file: preprocessing/query-preprocessor.node.ts
    reads: [query.originalQuery, query.context]
    writes: [query.processedQuery]
    validate: { field: query, ref: UNIFIED-STATE-SPEC.md#QueryMetadata }

  - name: NerExtractorNode
    file: extraction/ner-extractor.node.ts
    reads: [query.processedQuery]
    writes: [signals.nerResults]

  - name: NameResolverNode
    file: extraction/name-resolver.node.ts
    reads: [query.processedQuery]
    writes: [signals.resolvedToolNames]

  - name: FuzzyMatcherNode
    file: extraction/fuzzy-matcher.node.ts
    reads: [query.processedQuery]
    writes: [signals.fuzzyMatches]

  - name: ZeroShotClassifierNode
    file: extraction/zero-shot-classifier.node.ts
    reads: [query.processedQuery, signals]
    writes: [signals.semanticSignals.classifications]

  - name: SemanticPrefilterNode
    file: extraction/semantic-prefilter.node.ts
    reads: [query.processedQuery]
    writes: [signals.semanticSignals.embeddings, signals.semanticSignals.semanticScore]

  - name: ComparativeDetectorNode
    file: extraction/comparative-detector.node.ts
    reads: [query.processedQuery]
    writes: [signals.comparativeSignals]

  - name: InterfaceDetectorNode
    file: extraction/interface-detector.node.ts
    reads: [query.processedQuery]
    writes: [signals.attributeSignals.interfaces]

  - name: DeploymentDetectorNode
    file: extraction/deployment-detector.node.ts
    reads: [query.processedQuery]
    writes: [signals.attributeSignals.deploymentTypes]

  - name: PriceExtractorNode
    file: extraction/price-extractor.node.ts
    reads: [query.processedQuery]
    writes: [signals.attributeSignals.priceRange]

  - name: ReferenceExtractorNode
    file: extraction/reference-extractor.node.ts
    reads: [query.processedQuery]
    writes: [signals.referenceSignals]

  - name: IntentSynthesizerNode
    file: extraction/intent-synthesizer.node.ts
    reads: [signals]
    writes: [intent]
    validate: { field: intent, ref: ./states-docs/intent.md#IntentState }

  - name: ScoreCombinerNode
    file: extraction/score-combiner.node.ts
    reads: [signals.semanticSignals, intent]
    writes: [signals.semanticSignals.semanticScore]

  - name: ContextEnrichmentNode
    file: context-enrichment.node.ts
    reads: [intent, signals]
    writes: [context]

  - name: OptimalPlannerNode
    file: planning/optimal-planner.node.ts
    reads: [intent, signals, context]
    writes: [planning.chosenStrategy, planning.plans, planning.confidence]
    validate: { field: planning, ref: ./states-docs/query-planner.md#QueryPlan }

  - name: MultiStrategyPlannerNode
    file: planning/multi-strategy-planner.node.ts
    reads: [intent, signals, context]
    writes: [planning.chosenStrategy, planning.plans]
    validate: { field: planning, ref: ./states-docs/query-planner.md#QueryPlan }

  - name: FallbackPlannerNode
    file: planning/fallback-planner.node.ts
    reads: [intent, signals]
    writes: [planning.chosenStrategy, planning.plans]

  - name: ExpansionPlannerNode
    file: planning/expansion-planner.node.ts
    reads: [planning]
    writes: [planning.plans[*].queries, planning.plans[*].filters]

  - name: RefinementPlannerNode
    file: planning/refinement-planner.node.ts
    reads: [planning]
    writes: [planning.plans[*].weights, planning.plans[*].filters]

  - name: PlanValidatorNode
    file: planning/plan-validator.node.ts
    reads: [planning]
    writes: [planning.validationResults, planning.confidence]

  - name: SinglePlanExecutorNode
    file: execution/single-plan-executor.node.ts
    reads: [planning]
    writes: [execution.executionStrategy, execution.queries, execution.results, execution.totalExecutionTime, execution.qualityMetrics]
    validate: { field: execution, ref: ./states-docs/query-executor.md#Output }

  - name: MultiStrategyExecutorNode
    file: execution/multi-strategy-executor.node.ts
    reads: [planning]
    writes: [execution.executionStrategy, execution.queries, execution.results, execution.totalExecutionTime, execution.qualityMetrics]
    validate: { field: execution, ref: ./states-docs/query-executor.md#Output }

  - name: MultiVectorSearchNode
    file: multi-vector-search.node.ts
    reads: [planning]
    writes: [execution.queries, execution.results]

  - name: ResultMergerNode
    file: execution/result-merger.node.ts
    reads: [execution.results]
    writes: [results.mergingStrategy, results.mergedResults, results.deduplicationStats, results.qualityAssessment, results.processingTime]

  - name: ResultMergerNodeLegacy
    file: result-merger.node.ts
    reads: [execution.results]
    writes: [results.mergedResults]

  - name: CompletionNode
    file: execution/completion.node.ts
    reads: [results, intent, execution]
    writes: [completion.optimizedResults, completion.quality, completion.performance, completion.metadata.decisions]

  - name: ConfidenceEvaluatorNode
    file: routing/confidence-evaluator.node.ts
    reads: [intent.confidence.overall, planning.confidence, execution.qualityMetrics]
    writes: [metadata.debug.logs, metadata.debug.checkpoints, metadata.debug.executionPath, metadata.performance.nodeTimings]

  - name: QualityEvaluatorNode
    file: routing/quality-evaluator.node.ts
    reads: [results.qualityAssessment, execution.qualityMetrics]
    writes: [completion.quality, metadata.debug.logs, metadata.performance.nodeTimings]

  - name: ConditionalExecutorNode
    file: conditional-executor.node.ts
    reads: [intent, planning, optimizationHints]
    writes: [optimizationHints.skipStages, optimizationHints.preferStrategies, metadata.debug.checkpoints]

  - name: DynamicStageSkipperNode
    file: dynamic-stage-skipper.node.ts
    reads: [optimizationHints, metadata.performance]
    writes: [optimizationHints.skipStages]

  - name: LocalNlpProcessingNode
    file: local-nlp-processing.node.ts
    reads: [query.processedQuery]
    writes: [signals.semanticSignals.classifications, signals.attributeSignals.features]

deterministic_boundaries:
  - stage: intent
    validate: intent
    ajv_ref: ./states-docs/intent.md
  - stage: planning
    validate: planning
    ajv_ref: ./states-docs/query-planner.md
  - stage: execution
    validate: execution
    ajv_ref: ./states-docs/query-executor.md
  - stage: results
    validate: results
    ajv_ref: type-guard
  - stage: completion
    validate: completion
    ajv_ref: type-guard

routing_contracts:
  - name: budget_controller
    reads: [metadata.performance.totalExecutionTime, metadata.performance.memoryUsage]
    writes: [optimizationHints.resourceLimits]
    decisions: [route_paths]

  - name: safety_gate
    reads: [results.mergedResults, completion.optimizedResults]
    writes: [metadata.debug.logs, errors[*]]