# Deployment Workflow
# Handles deployment of frontend and/or search-api services to staging and production

name: Deployment

on:
  workflow_dispatch:
    inputs:
      service:
        description: 'Service to deploy'
        required: true
        type: choice
        options:
        - frontend
        - search-api
        - both
      image:
        description: 'Docker image to deploy (if single service)'
        required: false
        type: string
      frontend_image:
        description: 'Frontend docker image (if deploying both)'
        required: false
        type: string
      search_api_image:
        description: 'Search API docker image (if deploying both)'
        required: false
        type: string
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production

env:
  STAGING_URL: https://staging.codiesvibe.com
  PRODUCTION_URL: https://codiesvibe.com

jobs:
  validate-inputs:
    name: Validate Deployment Inputs
    runs-on: ubuntu-latest
    outputs:
      frontend_image: ${{ steps.validate.outputs.frontend_image }}
      search_api_image: ${{ steps.validate.outputs.search_api_image }}
      deploy_frontend: ${{ steps.validate.outputs.deploy_frontend }}
      deploy_search_api: ${{ steps.validate.outputs.deploy_search_api }}

    steps:
      - name: Validate deployment inputs
        id: validate
        run: |
          echo "Validating deployment configuration..."

          SERVICE="${{ inputs.service }}"
          ENVIRONMENT="${{ inputs.environment }}"

          echo "Service: $SERVICE"
          echo "Environment: $ENVIRONMENT"

          if [ "$SERVICE" = "frontend" ]; then
            if [ -z "${{ inputs.image }}" ]; then
              echo "‚ùå Frontend image required when deploying frontend service"
              exit 1
            fi
            echo "frontend_image=${{ inputs.image }}" >> $GITHUB_OUTPUT
            echo "deploy_frontend=true" >> $GITHUB_OUTPUT
            echo "deploy_search_api=false" >> $GITHUB_OUTPUT

          elif [ "$SERVICE" = "search-api" ]; then
            if [ -z "${{ inputs.image }}" ]; then
              echo "‚ùå Search API image required when deploying search-api service"
              exit 1
            fi
            echo "search_api_image=${{ inputs.image }}" >> $GITHUB_OUTPUT
            echo "deploy_frontend=false" >> $GITHUB_OUTPUT
            echo "deploy_search_api=true" >> $GITHUB_OUTPUT

          elif [ "$SERVICE" = "both" ]; then
            if [ -z "${{ inputs.frontend_image }}" ] || [ -z "${{ inputs.search_api_image }}" ]; then
              echo "‚ùå Both frontend and search-api images required when deploying both services"
              exit 1
            fi
            echo "frontend_image=${{ inputs.frontend_image }}" >> $GITHUB_OUTPUT
            echo "search_api_image=${{ inputs.search_api_image }}" >> $GITHUB_OUTPUT
            echo "deploy_frontend=true" >> $GITHUB_OUTPUT
            echo "deploy_search_api=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Invalid service: $SERVICE"
            exit 1
          fi

          echo "‚úÖ Deployment configuration validated"

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: validate-inputs
    if: inputs.environment == 'staging'
    environment:
      name: staging
      url: ${{ env.STAGING_URL }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH key
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY_STAGING }}

      - name: Deploy to staging server
        run: |
          set -e

          echo "üöÄ Deploying ${{ inputs.service }} to staging..."

          # Copy necessary files
          scp -o StrictHostKeyChecking=no docker-compose.production.yml ${{ secrets.SSH_USER_STAGING }}@${{ secrets.SSH_HOST_STAGING }}:~/codiesvibe/
          scp -o StrictHostKeyChecking=no nginx.conf ${{ secrets.SSH_USER_STAGING }}@${{ secrets.SSH_HOST_STAGING }}:~/codiesvibe/

          # Deploy with docker-compose
          ssh -o StrictHostKeyChecking=no ${{ secrets.SSH_USER_STAGING }}@${{ secrets.SSH_HOST_STAGING }} << 'EOF'
            set -e
            cd ~/codiesvibe

            # Create backup
            if docker-compose -f docker-compose.production.yml ps -q | grep -q .; then
              docker-compose -f docker-compose.production.yml config > backup-compose-$(date +%Y%m%d-%H%M%S).yml
              echo "‚úÖ Backup created"
            fi

            # Set environment variables
            export VERSION=${{ github.sha }}
            export ENVIRONMENT=staging

            # Set service-specific images
            if [ "${{ needs.validate-inputs.outputs.deploy_frontend }}" = "true" ]; then
              export FRONTEND_IMAGE=${{ needs.validate-inputs.outputs.frontend_image }}
              echo "Frontend image: $FRONTEND_IMAGE"
            fi

            if [ "${{ needs.validate-inputs.outputs.deploy_search_api }}" = "true" ]; then
              export SEARCH_API_IMAGE=${{ needs.validate-inputs.outputs.search_api_image }}
              echo "Search API image: $SEARCH_API_IMAGE"
            fi

            # Start infrastructure
            docker-compose -f docker-compose.infra.yml up -d
            sleep 30

            # Deploy application
            echo "üöÄ Deploying application..."
            docker-compose -f docker-compose.production.yml pull

            # Deploy specific services or all
            if [ "${{ inputs.service }}" = "frontend" ]; then
              docker-compose -f docker-compose.production.yml up -d --force-recreate frontend nginx
            elif [ "${{ inputs.service }}" = "search-api" ]; then
              docker-compose -f docker-compose.production.yml up -d --force-recreate search-api
            else
              docker-compose -f docker-compose.production.yml up -d --force-recreate
            fi

            # Wait for services to be healthy
            echo "‚è≥ Waiting for services to be healthy..."
            timeout 300 bash -c 'until docker-compose -f docker-compose.production.yml ps | grep -q "healthy"; do echo "Waiting..."; sleep 5; done' || {
              echo "‚ùå Services failed to become healthy within 5 minutes"
              exit 1
            }

            echo "‚úÖ Staging deployment completed successfully"
          EOF

      - name: Health check staging
        run: |
          echo "Running staging health checks..."
          sleep 60

          if [ "${{ needs.validate-inputs.outputs.deploy_frontend }}" = "true" ]; then
            echo "Checking frontend health..."
            curl -f ${{ env.STAGING_URL }}/health || exit 1

            # Check response time
            RESPONSE_TIME=$(curl -o /dev/null -s -w '%{time_total}' ${{ env.STAGING_URL }}/)
            echo "Frontend response time: ${RESPONSE_TIME}s"
            if (( $(echo "$RESPONSE_TIME > 5.0" | bc -l) )); then
              echo "‚ö†Ô∏è Frontend response time slow: ${RESPONSE_TIME}s"
            fi
          fi

          if [ "${{ needs.validate-inputs.outputs.deploy_search_api }}" = "true" ]; then
            echo "Checking search-api health..."
            curl -f ${{ env.STAGING_URL }}/api/health || exit 1

            # Check API functionality
            curl -f "${{ env.STAGING_URL }}/api/search?q=test" || exit 1

            # Check response time
            API_RESPONSE_TIME=$(curl -o /dev/null -s -w '%{time_total}' ${{ env.STAGING_URL }}/api/health)
            echo "API response time: ${API_RESPONSE_TIME}s"
            if (( $(echo "$API_RESPONSE_TIME > 3.0" | bc -l) )); then
              echo "‚ö†Ô∏è API response time slow: ${API_RESPONSE_TIME}s"
            fi
          fi

          echo "‚úÖ Staging health checks passed"

      - name: Notify staging deployment
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: 'Staging deployment of ${{ inputs.service }} ${{ job.status }} for commit ${{ github.sha }}'
          fields: repo,message,commit,author,action,eventName,ref,workflow
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [validate-inputs, deploy-staging]
    if: inputs.environment == 'production' && (needs.deploy-staging.result == 'success' || needs.deploy-staging.result == 'skipped')
    environment:
      name: production
      url: ${{ env.PRODUCTION_URL }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH key
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY_PRODUCTION }}

      - name: Deploy to production server
        run: |
          set -e

          echo "üöÄ Deploying ${{ inputs.service }} to production..."

          # Copy necessary files
          scp -o StrictHostKeyChecking=no docker-compose.production.yml ${{ secrets.SSH_USER_PRODUCTION }}@${{ secrets.SSH_HOST_PRODUCTION }}:~/codiesvibe/
          scp -o StrictHostKeyChecking=no docker-compose.cloudflare.yml ${{ secrets.SSH_USER_PRODUCTION }}@${{ secrets.SSH_HOST_PRODUCTION }}:~/codiesvibe/
          scp -o StrictHostKeyChecking=no nginx.conf ${{ secrets.SSH_USER_PRODUCTION }}@${{ secrets.SSH_HOST_PRODUCTION }}:~/codiesvibe/

          # Deploy with Cloudflare tunnels
          ssh -o StrictHostKeyChecking=no ${{ secrets.SSH_USER_PRODUCTION }}@${{ secrets.SSH_HOST_PRODUCTION }} << 'EOF'
            set -e
            cd ~/codiesvibe

            # Create backup
            if docker-compose -f docker-compose.cloudflare.yml ps -q | grep -q .; then
              docker-compose -f docker-compose.cloudflare.yml config > backup-compose-$(date +%Y%m%d-%H%M%S).yml
              echo "‚úÖ Production backup created"
            fi

            # Set environment variables
            export VERSION=${{ github.sha }}
            export ENVIRONMENT=production

            # Set service-specific images
            if [ "${{ needs.validate-inputs.outputs.deploy_frontend }}" = "true" ]; then
              export FRONTEND_IMAGE=${{ needs.validate-inputs.outputs.frontend_image }}
              echo "Frontend image: $FRONTEND_IMAGE"
            fi

            if [ "${{ needs.validate-inputs.outputs.deploy_search_api }}" = "true" ]; then
              export SEARCH_API_IMAGE=${{ needs.validate-inputs.outputs.search_api_image }}
              echo "Search API image: $SEARCH_API_IMAGE"
            fi

            # Start infrastructure
            docker-compose -f docker-compose.infra.yml up -d
            sleep 30

            # Deploy with Cloudflare tunnels
            echo "üöÄ Deploying to production with Cloudflare..."
            docker-compose -f docker-compose.cloudflare.yml pull

            # Deploy specific services or all
            if [ "${{ inputs.service }}" = "frontend" ]; then
              docker-compose -f docker-compose.cloudflare.yml up -d --force-recreate frontend nginx
            elif [ "${{ inputs.service }}" = "search-api" ]; then
              docker-compose -f docker-compose.cloudflare.yml up -d --force-recreate search-api
            else
              docker-compose -f docker-compose.cloudflare.yml up -d --force-recreate
            fi

            # Wait for services to be healthy (longer timeout for production)
            echo "‚è≥ Waiting for services to be healthy..."
            timeout 600 bash -c 'until docker-compose -f docker-compose.cloudflare.yml ps | grep -q "healthy"; do echo "Waiting..."; sleep 10; done' || {
              echo "‚ùå Services failed to become healthy within 10 minutes"
              exit 1
            }

            echo "‚úÖ Production deployment completed successfully"
          EOF

      - name: Health check production
        run: |
          echo "Running production health checks..."
          sleep 90

          if [ "${{ needs.validate-inputs.outputs.deploy_frontend }}" = "true" ]; then
            echo "Checking production frontend..."
            curl -f ${{ env.PRODUCTION_URL }}/health || exit 1

            # Check response time (stricter for production)
            RESPONSE_TIME=$(curl -o /dev/null -s -w '%{time_total}' ${{ env.PRODUCTION_URL }}/)
            echo "Production frontend response time: ${RESPONSE_TIME}s"
            if (( $(echo "$RESPONSE_TIME > 3.0" | bc -l) )); then
              echo "‚ùå Production frontend response time too slow: ${RESPONSE_TIME}s"
              exit 1
            fi
          fi

          if [ "${{ needs.validate-inputs.outputs.deploy_search_api }}" = "true" ]; then
            echo "Checking production search-api..."
            curl -f ${{ env.PRODUCTION_URL }}/api/health || exit 1

            # Check API functionality
            curl -f "${{ env.PRODUCTION_URL }}/api/search?q=test" || exit 1

            # Check response time
            API_RESPONSE_TIME=$(curl -o /dev/null -s -w '%{time_total}' ${{ env.PRODUCTION_URL }}/api/health)
            echo "Production API response time: ${API_RESPONSE_TIME}s"
            if (( $(echo "$API_RESPONSE_TIME > 2.0" | bc -l) )); then
              echo "‚ùå Production API response time too slow: ${API_RESPONSE_TIME}s"
              exit 1
            fi
          fi

          # Check Cloudflare integration
          CF_RAY_ID=$(curl -s -I ${{ env.PRODUCTION_URL }}/ | grep -i cf-ray | cut -d' ' -f2)
          if [ -z "$CF_RAY_ID" ]; then
            echo "‚ùå Cloudflare integration not working"
            exit 1
          fi
          echo "‚úÖ Cloudflare Ray ID: $CF_RAY_ID"

          # Check SSL certificate
          SSL_EXPIRY=$(echo | openssl s_client -servername codiesvibe.com -connect codiesvibe.com:443 2>/dev/null | openssl x509 -noout -dates | grep notAfter | cut -d= -f2)
          echo "SSL certificate expires: $SSL_EXPIRY"

          echo "‚úÖ Production health checks passed"

      - name: Create GitHub Release
        if: startsWith(github.ref, 'refs/tags/v')
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.ref_name }}
          name: Release ${{ github.ref_name }}
          body: |
            ## Deployment Summary
            - Service: ${{ inputs.service }}
            - Environment: ${{ inputs.environment }}
            - Commit: ${{ github.sha }}

            ## Docker Images
            ${{ needs.validate-inputs.outputs.deploy_frontend == 'true' && format('- Frontend: {0}', needs.validate-inputs.outputs.frontend_image) || '' }}
            ${{ needs.validate-inputs.outputs.deploy_search_api == 'true' && format('- Search API: {0}', needs.validate-inputs.outputs.search_api_image) || '' }}

            ## Deployment Status
            - ‚úÖ Production: Deployed successfully

            ## Health Checks
            - ‚úÖ All services healthy
            - ‚úÖ Performance benchmarks passed
            - ‚úÖ Cloudflare integration working
          draft: false
          prerelease: false

      - name: Notify production deployment
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: 'Production deployment of ${{ inputs.service }} ${{ job.status }} for commit ${{ github.sha }}'
          fields: repo,message,commit,author,action,eventName,ref,workflow
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  post-deployment:
    name: Post-Deployment Tasks
    runs-on: ubuntu-latest
    needs: [validate-inputs, deploy-staging, deploy-production]
    if: always() && (needs.deploy-staging.result == 'success' || needs.deploy-production.result == 'success')

    steps:
      - name: Update deployment status
        run: |
          echo "=== Deployment Summary ==="
          echo "Service: ${{ inputs.service }}"
          echo "Environment: ${{ inputs.environment }}"
          echo "Staging: ${{ needs.deploy-staging.result }}"
          echo "Production: ${{ needs.deploy-production.result }}"

          if [ "${{ inputs.environment }}" = "production" ]; then
            if [ "${{ needs.deploy-production.result }}" = "success" ]; then
              echo "‚úÖ Production deployment successful"
            else
              echo "‚ùå Production deployment failed"
              exit 1
            fi
          else
            if [ "${{ needs.deploy-staging.result }}" = "success" ]; then
              echo "‚úÖ Staging deployment successful"
            else
              echo "‚ùå Staging deployment failed"
              exit 1
            fi
          fi

      - name: Trigger monitoring alerts
        if: inputs.environment == 'production'
        run: |
          # This could trigger external monitoring systems
          echo "Production deployment completed - monitoring systems notified"
